package aion.dashboard.task;

import aion.dashboard.domainobject.Graphing;
import aion.dashboard.service.GraphingService;
import aion.dashboard.service.GraphingServiceImpl;
import aion.dashboard.service.SchedulerService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Duration;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

public abstract class AbstractGraphingTask<T>  implements Runnable{



    public enum TaskType{
        DB, KERNEL
    }


    public static AbstractGraphingTask getInstance(TaskType type) {

        switch (Objects.requireNonNull(type)){

            case DB:
                return DBGraphingTask.DB_GRAPHING_TASK;
            case KERNEL:
                return GraphingTask.API_GRAPHING_TASK;
            default:
                throw new IllegalArgumentException("Invalid argument");
        }
    }



    protected GraphingService graphingService = GraphingServiceImpl.getInstance();
    protected static final Logger GENERAL = LoggerFactory.getLogger("logger_general");

    abstract List<Graphing> compute(List<T> blocks) throws Exception;
    private static final int INITIAL_DELAY = 5;
    private static final int DELAY_AT_END_OF_HOUR = 2;

    protected static final ZoneId UTCZoneID = ZoneId.of("UTC");

    public ScheduledFuture getFuture() {
        return future;
    }
    private volatile ScheduledFuture future;

    public void stop(){
        future.cancel(true);
    }

    final void scheduleNext() {
        LocalDateTime localNow = LocalDateTime.now();
        ZoneId currentZone = ZoneId.systemDefault();
        ZonedDateTime zonedNow = ZonedDateTime.of(localNow, currentZone);

        ZonedDateTime zonedDateTime = zonedNow.withSecond(0).plusHours(1).withMinute(DELAY_AT_END_OF_HOUR);

        GENERAL.debug("Next execution scheduled at {}", zonedDateTime);

        Duration duration = Duration.between(zonedNow, zonedDateTime);
        long delay = duration.getSeconds();//get the next hour in which this task should run

        future = SchedulerService.getInstance().addRunOnce(this, delay, TimeUnit.SECONDS);//run the graphing service 2 minutes after the hour to allow for additional blocks to be imported
        //this is a safe guard against running the service before all blocks have been added to the DB

    }

    public final void scheduleNow(){
        ZonedDateTime timeNow = ZonedDateTime.now(UTCZoneID);
        ZonedDateTime timeNextHour = ZonedDateTime.now(UTCZoneID).plusHours(1).withMinute(DELAY_AT_END_OF_HOUR).withSecond(0);
        Duration diff = Duration.between(timeNow, timeNextHour);


        if (diff.toMinutes() <= 10 ) {
            scheduleNext();// If the time to the next hour is less than 10 minutes schedule in the next hour
        } else {
            //Schedule the service to run in the background now
            GENERAL.debug("Next execution of Graphing Task scheduled at {}", timeNow.plusMinutes(INITIAL_DELAY));

            future = SchedulerService.getInstance().addRunOnce(this, INITIAL_DELAY, TimeUnit.MINUTES);
        }
    }
}
